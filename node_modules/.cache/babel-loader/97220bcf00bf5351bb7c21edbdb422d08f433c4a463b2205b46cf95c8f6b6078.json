{"ast":null,"code":"var _s = $RefreshSig$();\n//Onde faco o carregamento das perguntas\n//Crio hook quando desejo padronizar funcionalidades, e componentes para elementos visuais.\n//Trago para este hook todas as funcionalidades que irao funcionar da mesma forma tanto para a sala do usuario quanto do admin.\n\nimport { useEffect, useState } from \"react\";\nimport { database } from \"../services/firebase\";\nimport { useAuth } from \"./useAuth\";\n\n//Para declarar tipagem de objetos no TS uso Record<tipo da chave, tipo do valor - que nesse caso e outro objeto>\n\nexport function useRoom(roomId) {\n  _s();\n  const {\n    user\n  } = useAuth();\n  const [questions, setQuestions] = useState([]);\n  const [title, setTitle] = useState('');\n\n  //useEffect, dispara um evento sempre que alguma informacao mudar\n  useEffect(() => {\n    const roomRef = database.ref(`rooms/${roomId}`);\n\n    //Seguindo a documentacao do Firebase, digo ao Firebase que estou ouvindo um evento faz-se:\n    //.val e uma API do Firebase para buscar os valores que estao dentro da room\n    //roomRef.on -> toda vez que roomId mudar, ele vai executar o codigo abaixo novamente, e substituir as informacoes em tela\n    roomRef.on('value', room => {\n      var _databaseRoom$questio;\n      const databaseRoom = room.val();\n      const firebaseQuestions = (_databaseRoom$questio = databaseRoom.questions) !== null && _databaseRoom$questio !== void 0 ? _databaseRoom$questio : {};\n\n      //Implementando um \"Hashmap\". Object. entries em um objeto retorna um array com cada posicao contendo key e value de um objeto.\n      const parsedQuestions = Object.entries(firebaseQuestions).map(_ref => {\n        var _value$likes, _value$likes2;\n        let [key, value] = _ref;\n        return {\n          id: key,\n          content: value.content,\n          author: value.author,\n          isHighlighted: value.isHighlighted,\n          isAnswered: value.isAnswered,\n          likeCount: Object.values((_value$likes = value.likes) !== null && _value$likes !== void 0 ? _value$likes : {}).length,\n          //Os likes podem vir vazios, caso nao tenha nada: ?? {}\n          hasLiked: Object.values((_value$likes2 = value.likes) !== null && _value$likes2 !== void 0 ? _value$likes2 : {}).some(like => like.authorId === (user === null || user === void 0 ? void 0 : user.id)) //some percorre o array atr encontrar uma condicao que satisfaca o que foi passado pra ele e retorna true ou false\n        };\n      });\n\n      setTitle(databaseRoom.title);\n      setQuestions(parsedQuestions);\n    });\n  }, [roomId, user === null || user === void 0 ? void 0 : user.id]);\n  return {\n    questions,\n    title\n  };\n}\n_s(useRoom, \"EYvzB2c8NzRJMdh6moXTIjwz5jY=\", false, function () {\n  return [useAuth];\n});","map":{"version":3,"names":["useEffect","useState","database","useAuth","useRoom","roomId","user","questions","setQuestions","title","setTitle","roomRef","ref","on","room","databaseRoom","val","firebaseQuestions","parsedQuestions","Object","entries","map","key","value","id","content","author","isHighlighted","isAnswered","likeCount","values","likes","length","hasLiked","some","like","authorId"],"sources":["/Users/mtrindade/Documents/Dev_Docs/Projetos/LetMeAsk_Project/src/hooks/useRoom.ts"],"sourcesContent":["//Onde faco o carregamento das perguntas\n//Crio hook quando desejo padronizar funcionalidades, e componentes para elementos visuais.\n//Trago para este hook todas as funcionalidades que irao funcionar da mesma forma tanto para a sala do usuario quanto do admin.\n\nimport { useEffect, useState } from \"react\";\nimport { database } from \"../services/firebase\";\nimport { useAuth } from \"./useAuth\";\n\n//Para declarar tipagem de objetos no TS uso Record<tipo da chave, tipo do valor - que nesse caso e outro objeto>\ntype FirebaseQuestions = Record<string, {\n    author: {\n        name: string;\n        avatar: string;\n    }\n    content: string; \n    isAnswered: boolean;\n    isHighlighted: boolean;\n    //likes - are objects, with a key as string.\n    likes: Record<string, {\n        authorId: string;\n    }>\n}>\n\ntype Question = {\n    id:string;\n    author: {\n        name: string;\n        avatar: string;\n    }\n    content: string; \n    isAnswered: boolean;\n    isHighlighted: boolean;\n}\n\nexport function useRoom (roomId: string | undefined) {\n    const { user} = useAuth();\n    const [questions, setQuestions] = useState<Question[]>([])\n    const [title, setTitle] = useState('');\n\n        //useEffect, dispara um evento sempre que alguma informacao mudar\n        useEffect(() => {\n            const roomRef = database.ref(`rooms/${roomId}`);\n            \n            //Seguindo a documentacao do Firebase, digo ao Firebase que estou ouvindo um evento faz-se:\n            //.val e uma API do Firebase para buscar os valores que estao dentro da room\n            //roomRef.on -> toda vez que roomId mudar, ele vai executar o codigo abaixo novamente, e substituir as informacoes em tela\n            roomRef.on('value', room => {\n                const databaseRoom = room.val();\n                const firebaseQuestions: FirebaseQuestions = databaseRoom.questions ?? {};\n                \n                //Implementando um \"Hashmap\". Object. entries em um objeto retorna um array com cada posicao contendo key e value de um objeto.\n                const parsedQuestions= Object.entries(firebaseQuestions).map(([key, value]) => {\n                    return {\n                        id: key,\n                        content: value.content,\n                        author: value.author,\n                        isHighlighted: value.isHighlighted,\n                        isAnswered: value.isAnswered,\n                        likeCount: Object.values(value.likes ?? {}).length, //Os likes podem vir vazios, caso nao tenha nada: ?? {}\n                        hasLiked: Object.values(value.likes ?? {}).some(like => like.authorId === user?.id) //some percorre o array atr encontrar uma condicao que satisfaca o que foi passado pra ele e retorna true ou false\n                    }\n                })\n    \n                setTitle(databaseRoom.title);\n                setQuestions(parsedQuestions)\n                \n            })\n        }, [roomId, user?.id]);\n    \n    return {questions, title}\n}"],"mappings":";AAAA;AACA;AACA;;AAEA,SAASA,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAC3C,SAASC,QAAQ,QAAQ,sBAAsB;AAC/C,SAASC,OAAO,QAAQ,WAAW;;AAEnC;;AA0BA,OAAO,SAASC,OAAO,CAAEC,MAA0B,EAAE;EAAA;EACjD,MAAM;IAAEC;EAAI,CAAC,GAAGH,OAAO,EAAE;EACzB,MAAM,CAACI,SAAS,EAAEC,YAAY,CAAC,GAAGP,QAAQ,CAAa,EAAE,CAAC;EAC1D,MAAM,CAACQ,KAAK,EAAEC,QAAQ,CAAC,GAAGT,QAAQ,CAAC,EAAE,CAAC;;EAElC;EACAD,SAAS,CAAC,MAAM;IACZ,MAAMW,OAAO,GAAGT,QAAQ,CAACU,GAAG,CAAE,SAAQP,MAAO,EAAC,CAAC;;IAE/C;IACA;IACA;IACAM,OAAO,CAACE,EAAE,CAAC,OAAO,EAAEC,IAAI,IAAI;MAAA;MACxB,MAAMC,YAAY,GAAGD,IAAI,CAACE,GAAG,EAAE;MAC/B,MAAMC,iBAAoC,4BAAGF,YAAY,CAACR,SAAS,yEAAI,CAAC,CAAC;;MAEzE;MACA,MAAMW,eAAe,GAAEC,MAAM,CAACC,OAAO,CAACH,iBAAiB,CAAC,CAACI,GAAG,CAAC,QAAkB;QAAA;QAAA,IAAjB,CAACC,GAAG,EAAEC,KAAK,CAAC;QACtE,OAAO;UACHC,EAAE,EAAEF,GAAG;UACPG,OAAO,EAAEF,KAAK,CAACE,OAAO;UACtBC,MAAM,EAAEH,KAAK,CAACG,MAAM;UACpBC,aAAa,EAAEJ,KAAK,CAACI,aAAa;UAClCC,UAAU,EAAEL,KAAK,CAACK,UAAU;UAC5BC,SAAS,EAAEV,MAAM,CAACW,MAAM,iBAACP,KAAK,CAACQ,KAAK,uDAAI,CAAC,CAAC,CAAC,CAACC,MAAM;UAAE;UACpDC,QAAQ,EAAEd,MAAM,CAACW,MAAM,kBAACP,KAAK,CAACQ,KAAK,yDAAI,CAAC,CAAC,CAAC,CAACG,IAAI,CAACC,IAAI,IAAIA,IAAI,CAACC,QAAQ,MAAK9B,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEkB,EAAE,EAAC,CAAC;QACxF,CAAC;MACL,CAAC,CAAC;;MAEFd,QAAQ,CAACK,YAAY,CAACN,KAAK,CAAC;MAC5BD,YAAY,CAACU,eAAe,CAAC;IAEjC,CAAC,CAAC;EACN,CAAC,EAAE,CAACb,MAAM,EAAEC,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEkB,EAAE,CAAC,CAAC;EAE1B,OAAO;IAACjB,SAAS;IAAEE;EAAK,CAAC;AAC7B;AAAC,GApCeL,OAAO;EAAA,QACHD,OAAO;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}